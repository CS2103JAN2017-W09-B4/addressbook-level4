# A0139322L
###### \java\seedu\task\logic\commands\DeleteCommand.java
``` java
    public static final String TO_INDICATOR = "-";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing,\n"
            + "or, if two index numbers are provided, all tasks between the two index numbers used\n"
            + "in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer) [" + TO_INDICATOR + " SECOND_INDEX]\n"
            + "Example: " + COMMAND_WORD + " 1\n"
            + "or: " + COMMAND_WORD + " 1 " + TO_INDICATOR + " 5\n";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    public static final String MESSAGE_DELETE_TASKS_SUCCESS = "Deleted Tasks:\n";

```
###### \java\seedu\task\logic\commands\DeleteCommand.java
``` java
        if (times == 0) {
```
###### \java\seedu\task\logic\commands\DeleteCommand.java
``` java
        } else {
            if (lastShownList.size() < targetIndex || lastShownList.size() < (targetIndex + times - 1)) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            GlobalStack gStack = GlobalStack.getInstance();
            for (int i = 0; i < times; i++) {
                ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

                Task task = new Task(taskToDelete);
                task.setParserInfo("delete");
                task.setIndex(targetIndex - 1);
                try {
                    gStack.getUndoStack().push(task);

                    model.deleteTask(taskToDelete);
                    if (i == times - 1) {
                        subsetDeleted = subsetDeleted + String.format("%1$s", taskToDelete);
                    } else {
                        subsetDeleted = subsetDeleted + String.format("%1$s,\n", taskToDelete);
                    }
                } catch (TaskNotFoundException pnfe) {
                    assert false : "The target task(s) cannot be missing";
                }
            }

            Integer t = new Integer(times);
            gStack.getUndoStack().push(t);

            return new CommandResult(subsetDeleted);

        }
    }
```
###### \java\seedu\task\logic\commands\FindTagCommand.java
``` java

/**
 *  Find and lists all tasks in the task list which contain the specified tag.
 *  Only 1 tag can be searched at a time.
 *  Tag matching is case sensitive.
 */
public class FindTagCommand extends Command {

    public static final String COMMAND_WORD = "findtag";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks which contain "
            + "the specified tag (case-sensitive, restricted to 1 tag) and displays them as a list with index "
            + "numbers.\n"
            + "Parameters: TAG\n"
            + "Example: " + COMMAND_WORD + " School";
    public static final String MESSAGE_TOO_MANY_ARGUMENTS = "Only 1 tag can be searched at a time!";

    private final String tagName;

    public FindTagCommand(String tagName) {
        this.tagName = tagName;
    }

    @Override
    public CommandResult execute() throws CommandException, IllegalValueException {
        if (!(tagName.length() > 0 && tagName.split("\\s+").length == 2)) {
            System.out.println(tagName.length());
            System.out.println(tagName.split("\\s+").length);
            throw new IllegalValueException(MESSAGE_TOO_MANY_ARGUMENTS);
        }
        model.updateFilteredTagTaskList(tagName);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}

```
###### \java\seedu\task\logic\commands\RedoCommand.java
``` java
            } else if (toRedo.getClass() == Integer.class) {
                Integer times = (Integer) gStack.getRedoStack().pop();
                int intTimes = times.intValue();

                for (int i = 0; i < intTimes; i++) {
                    toRedo = gStack.getRedoStack().peek();
                    assert toRedo.getClass() == Task.class : "The target task(s) cannot be missing!";
                    ReadOnlyTask unmutableTask = gStack.redoDelete();
                    model.deleteTask(unmutableTask);
                }

                gStack.getUndoStack().push(times);
                return new CommandResult(MESSAGE_SUCCESS);
```
###### \java\seedu\task\logic\commands\UndoCommand.java
``` java
            } else if (toUndo.getClass() == Integer.class) {
                Integer times = (Integer) gStack.getUndoStack().pop();
                int intTimes = times.intValue();

                for (int i = 0; i < intTimes; i++) {
                    toUndo = gStack.getUndoStack().peek();
                    assert toUndo.getClass() == Task.class : "The target task(s) cannot be missing!";
                    gStack.undoDelete();
                    model.insertTasktoIndex(((Task) toUndo).getIndex(), (Task) toUndo);
                }

                gStack.getRedoStack().push(times);
                return new CommandResult(MESSAGE_SUCCESS);
```
###### \java\seedu\task\logic\parser\FindTagCommandParser.java
``` java
public class FindTagCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindTagCommand and returns a FindTagCommand object for execution
     */

    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                 String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                               FindTagCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        return new FindTagCommand(args);
    }
}
```
###### \java\seedu\task\logic\parser\Parser.java
``` java
        case FindTagCommand.COMMAND_WORD:
            return new FindTagCommandParser().parse(arguments);
```
###### \java\seedu\task\logic\parser\ParserUtil.java
``` java
    /**
     * Returns a new List populated by the elements in the {@code command} if there are 2 positive unsigned
     * integers in the command.
     * Returns a List populated by {@code Optional.empty()} objects otherwise.
     */
    public static ArrayList<OptionalInt> parseIndexes(String command) {
        String noSpaceCommand = command.replaceAll("\\s+", "");
        String[] indexStrings = noSpaceCommand.split("-");
        ArrayList<OptionalInt> indexes = new ArrayList<OptionalInt>(Arrays.asList(OptionalInt.empty(),
                                                                                  OptionalInt.empty()));

        if (indexStrings.length == 2) {
            if (!StringUtil.isUnsignedInteger(indexStrings[0]) || !StringUtil.isUnsignedInteger(indexStrings[1])) {
                return indexes;
            } else {
                OptionalInt index1 = OptionalInt.of(Integer.parseInt(indexStrings[0]));
                OptionalInt index2 = OptionalInt.of(Integer.parseInt(indexStrings[1]));
                indexes.set(0, index1);
                indexes.set(1, index2);
            }
        } else {
            return indexes;
        }

        return indexes;
    }
```
###### \java\seedu\task\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTagTaskList(String tagName) throws IllegalValueException {
        Tag tag;
        tag = new Tag(tagName);

        Predicate<? super ReadOnlyTask> pred = s -> s.getTags().contains(tag);
        filteredTasks.setPredicate(pred);
    }

```
###### \java\seedu\task\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            return totalKeyWords.stream()
                    .filter(keyword -> finalNearMatchSearch(task.getTaskName().taskName, keyword)
                            || finalNearMatchSearch(task.getInfo().value, keyword))
                    .findAny()
                    .isPresent();
        }
```
